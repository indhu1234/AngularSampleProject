"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Promise = require("core-js/features/promise");
var Domo = require("ryuu-client");
var request = require("request");
var utils_1 = require("../utils");
var constants_1 = require("../constants");
var Transport = /** @class */ (function () {
    function Transport(_a) {
        var manifest = _a.manifest;
        var _this = this;
        this.request = function (options) { return _this.clientPromise
            .then(function (client) { return client.processRequestRaw(options); }); };
        this.manifest = manifest;
        this.appContextId = utils_1.getProxyId(manifest);
        this.clientPromise = this.getLastLogin();
        this.domainPromise = this.getDomoDomain();
        this.oauthTokenPromise = this.getScopedOauthTokens();
    }
    Transport.prototype.getEnv = function (instance) {
        var regexp = /([-_\w]+)\.(.*)/;
        var int = 2;
        return instance.match(regexp)[int];
    };
    Transport.prototype.isDomoRequest = function (url) {
        var domoPattern = /^\/domo\/.+\/v\d/;
        var dataPattern = /^\/data\/v\d\/.+/;
        var sqlQueryPattern = /^\/sql\/v\d\/.+/;
        var dqlPattern = /^\/dql\/v\d\/.+/;
        var apiPattern = /^\/api\/.+/;
        return (domoPattern.test(url)
            || dataPattern.test(url)
            || sqlQueryPattern.test(url)
            || dqlPattern.test(url)
            || apiPattern.test(url));
    };
    Transport.prototype.isMultiPartRequest = function (headers) {
        return Object
            .entries(headers)
            .some(function (_a) {
            var header = _a[0], value = _a[1];
            return header.toLowerCase() === 'content-type'
                && value.toString().toLowerCase().includes('multipart');
        });
    };
    Transport.prototype.getManifest = function () {
        return this.manifest;
    };
    Transport.prototype.getDomainPromise = function () {
        return this.domainPromise;
    };
    Transport.prototype.getLastLogin = function () {
        return utils_1.getMostRecentLogin()
            .then(this.verifyLogin)
            .then(function (recentLogin) { return new Domo(recentLogin.instance, recentLogin.refreshToken, constants_1.CLIENT_ID); });
    };
    Transport.prototype.getScopedOauthTokens = function () {
        if (utils_1.isOauthEnabled(this.manifest)) {
            return utils_1.getOauthTokens(this.appContextId, this.manifest.scopes);
        }
        return new Promise(function (resolve) { return resolve(undefined); });
    };
    Transport.prototype.getDomoDomain = function () {
        var _this = this;
        var uuid = this.appContextId;
        var domoClient;
        return this.clientPromise
            .then(function (client) {
            domoClient = client;
            var options = {
                url: client.server + "/api/content/v1/mobile/environment",
            };
            return client.processRequest(options);
        })
            .then(function (res) { return "https://" + uuid + "." + JSON.parse(res).domoappsDomain; }, function () {
            var env = _this.getEnv(domoClient.instance);
            return "https://" + uuid + ".domoapps." + env;
        });
    };
    Transport.prototype.createContext = function () {
        var _this = this;
        return this.clientPromise
            .then(function (client) {
            var options = {
                method: 'POST',
                url: client.server + "/domoapps/apps/v2/contexts",
                json: { designId: _this.manifest.id, mapping: _this.manifest.mapping },
            };
            return client.processRequest(options);
        })
            .then(function (res) { return res[0]; });
    };
    Transport.prototype.build = function (req) {
        var _this = this;
        var options;
        return this.buildBasic(req)
            .then(function (basicOptions) {
            options = basicOptions;
            return _this.parseBody(req);
        })
            .then(function (body) {
            return __assign({}, options, { body: body });
        });
    };
    Transport.prototype.buildBasic = function (req) {
        var _this = this;
        var api;
        return this.domainPromise
            .then(function (domain) {
            api = "" + domain + req.url;
            return _this.createContext();
        })
            .then(function (context) { return (_this.prepareHeaders(req.headers, context.id)); })
            .then(function (headers) {
            var jar = request.jar();
            return {
                jar: jar,
                headers: headers,
                url: api,
                method: req.method,
            };
        });
    };
    Transport.prototype.prepareHeaders = function (headers, context) {
        var _this = this;
        return this.oauthTokenPromise.then(function (tokens) {
            if (!headers.hasOwnProperty('referer'))
                headers.referer = 'https://0.0.0.0:3000';
            var referer = (headers.referer.indexOf('?') >= 0)
                ? (headers.referer + "&context=" + context)
                : (headers.referer + "?userId=27&customer=dev&locale=en-US&platform=desktop&context=" + context);
            var cookieHeader = _this.prepareCookies(headers, tokens);
            var filters = (_this.isMultiPartRequest(headers))
                ? ([
                    'content-type',
                    'content-length',
                    'cookie',
                ])
                : ([
                    'cookie',
                ]);
            return __assign({}, Object.keys(headers).reduce(function (newHeaders, key) {
                if (!filters.includes(key.toLowerCase())) {
                    newHeaders[key] = headers[key];
                }
                return newHeaders;
            }, {}), cookieHeader, { referer: referer, host: undefined });
        });
    };
    Transport.prototype.prepareCookies = function (headers, tokens) {
        var existingCookie = Object.keys(headers).reduce(function (newHeaders, key) {
            if (key.toLowerCase() === 'cookie') {
                // handle if cookie is an array
                if (Array.isArray(headers[key])) {
                    newHeaders['cookie'] = headers[key].join('; ');
                }
                else {
                    newHeaders['cookie'] = headers[key];
                }
            }
            return newHeaders;
        }, {});
        var tokenCookie = (tokens !== undefined)
            ? ({ cookie: "_daatv1=" + tokens.access + "; _dartv1=" + tokens.refresh })
            : ({});
        if (existingCookie['cookie'] !== undefined && tokenCookie['cookie'] !== undefined) {
            return ({ cookie: existingCookie['cookie'] + "; " + tokenCookie['cookie'] });
        }
        if (existingCookie['cookie'] === undefined) {
            return tokenCookie;
        }
        return existingCookie;
    };
    Transport.prototype.parseBody = function (req) {
        // if body-parser was used before this middleware the "body" attribute will be set
        var exprReq = req;
        if (typeof exprReq.body !== 'undefined') {
            if (typeof exprReq.body === 'string')
                return Promise.resolve(exprReq.body);
            return Promise.resolve(JSON.stringify(exprReq.body));
        }
        return new Promise(function (resolve) {
            var body = [];
            try {
                req.on('data', function (chunk) { return body.push(chunk); });
                req.on('end', function () {
                    var raw = Buffer.concat(body).toString();
                    resolve(raw);
                });
                req.on('error', function () { return resolve(null); });
            }
            catch (e) {
                resolve();
            }
        });
    };
    Transport.prototype.verifyLogin = function (login) {
        if (!login.refreshToken) {
            throw new Error('Not authenticated. Please login using "domo login"');
        }
        return login;
    };
    return Transport;
}());
exports.default = Transport;
//# sourceMappingURL=index.js.map